# Goroutine, defer, panic, recover

Goroutines are also often called green threads. Green threads are maintained and scheduled by the language runtime instead of the operating systems. The cost of memory consumption and context switching, of a goroutine is much lesser than an OS thread.

## Concurrency Synchronization

A live goroutine may stay in (and switch between) two states, running and blocking. A goroutine is still considered to be running if it is asleep (aftter calling time.Sleep function) or awaiting the response of a system call or a network connection.

When a goroutine is created, it will enter the running state automatically. Goroutines can only exit from running state, and never from blocking state. If for any reason, a goroutine stays in blocking state forever, then it will never exit.

A blocking goroutine can only be unblocked by an operation made in another goroutine. If all goroutines in a Go program are in blocking state, then all of them will stay in blocking state forever.

## Goroutine Schedule

Not all goroutines in running state are being executed at a given time. At any given time, the maximum number of goroutines being executed will not exeed the number of logical CPUs avaialable for the current program. Each logical CPU can only execute one goroutine at any given time.

Go runtime must frequently switch execution contexts between goroutines to let each running goroutine have a chance to execute. This is similar to how operating systems switch execution contexts between OS threads.

## Goroutine Schedule

Not all goroutines in running state are being executed at a given time. At any given time, the maximum number of goroutines being executed will not execeed the number of logical CPUs available for the current goroutine. Each logical CPU can only execute one goroutine at any given time. Go routine must frequently switch execution contexts between goroutines to let each running goroutine have a chance to execute.

## Deferred Function Calls