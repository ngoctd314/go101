# Code and project organization

## Unintended variable shadowing

In Go, a variable name declared in a block may be redeclared in an inner block. This principles, called variable shadowing, is prone to common mistakes.

```go
// stupid
var client *http.Client
if tracing {
    // client is shadowed (redeclared) in this block 
    client, err := createClientWithTracing()
    if err != nil {
        return err
    }
    log.Println(client)
}
// use client
```

```go
// solution 1
var client *http.Client 
if tracing {
    c, err := createClientWithTracing()
    if err != nil {
        return err
    }
    client = c
}
// use client
```

```go
// solution 2
var client *http.Client
var err error
if tracing {
    client, err = createClientWithTracing()
    if err != nil {
        return err
    }
} else {
    // 
}
// use client
```

## Unnecessary nested code

```go
if s1 == "" {
    return err
} else {
    if s2 == "" {
        return err
    } else {
        if s3 == "" {
            return err
        } else {
            return 
        }
    }
}
```

## Misusing init functions

init functions are sometimes misused in Go applications. The potential consequences are poor error management or a code flow that is harder to understand. 

### Concepts

An init function is a function taking no arguments and returining no result (a func() function). When a package is initialized, all the constants and variables declarations in the package are evaluated. Then the init functions are executed.

```go
var a = func() any {
	fmt.Println("Run first")
	return nil
}()

func init() {
	fmt.Println("init function")
}

func main() {
	fmt.Println("Run main")
}
```

### When to use init functions

```go
var db *sql.DB
func init() {
    dataSourceName := os.Getenv("MYSQL_DATA_SOURCE_NAME")
    d, err := sql.Open("mysql", dataSourceName)
    if err != nil {
        log.Panic(err)
    }
    err = d.Ping()
    if err != nil {
        log.Panic(err)
    }
    db = d
}
```

Let's describe three main downsides.

First, error management in an init function is limited. Only ways to signal an error is to panic

Another downside is related to testing. If we add tests to this file, the init function will be executed before running the test cases

The last downsides is that it requires assigning the database connection pool to a global variable. Global variables have some severe drawbacks

- Any functions can alter them
- Make unit tests more complicated

## Overusing getters and setters

```go
currentBanlance := customer.Balance()
if currentBanlance < 0 {
    customer.SetBalance(0)
}
```

## Interface pollution